{"name":"GH","body":"This is a highly flexible, layered, low-level GitHub client library, trying to get out of your way and let you get to the GitHub data as simple as possible. Unless you add layers, you will end up with Hashes and Arrays. The approach and API should be familiar from projects like Rack or Faraday.\r\n\r\nSimple example:\r\n\r\n``` ruby\r\nrequire 'gh'\r\nputs GH['users/rkh']['name']\r\n```\r\n\r\nThis will by default use all the middleware that ships with GH, in the following order\r\n\r\n* `GH::Remote` - sends HTTP requests to GitHub and parses the response\r\n* `GH::Normalizer` - renames fields consistenly, adds hypermedia links if possible\r\n* `GH::Cache` - caches the responses (will use Rails cache if in Rails, in-memory cache otherwise)\r\n* `GH::LazyLoader` - will load missing fields when accessed (handy for dealing with incomplete data without sending to many requests)\r\n* `GH::LinkFollower` - will add content of hypermedia links as fields (lazyly), allows you to traverse relations\r\n\r\n### Main Entry Points\r\n\r\nEvery layer has two main entry points:\r\n\r\n* `[key]` - loads data from GitHub\r\n* `load(data)` - takes data and applies modifications (handy for dealing with service hook payloads)\r\n\r\nThese two methods are exposed by any instance of a layer and the `GH` constant.\r\n\r\n### Using a Single Layer\r\n\r\nYou can initialize and use any layer on its own:\r\n\r\n``` ruby\r\ngh = GH::Remote.new\r\nputs gh['users/rkh']['name']\r\n```\r\n\r\nLayers know which other layer they should usually wrap (`Remote` wraps no other layer, `LazyLoader` and `LinkFollower` wrap `Normalizer` by default, anything else wraps `Remote`), so you can initialize them right away:\r\n\r\n``` ruby\r\ngh = GH::LazyLoader.new\r\n```\r\n\r\nYou can also pass the layer that should be wrapped as an argument:\r\n\r\n``` ruby\r\ngh = GH::LazyLoader.new(GH::LinkFollower.new)\r\n```\r\n\r\n### Creating Your Own Stack\r\n\r\nFor convinience a stack DSL is provided:\r\n\r\n``` ruby\r\n# Same as GH::Normalizer.new(GH::Cache.new)\r\ngh = GH::Stack.build do\r\n  use GH::Normalizer\r\n  use GH::Cache\r\nend\r\n\r\nputs gh['users/rkh']['name']\r\n```\r\n\r\nYou can also create reusable `Stack` instances:\r\n\r\n``` ruby\r\nstack = GH::Stack.new do\r\n  use GH::Normalizer\r\n  use GH::Cache\r\nend\r\n\r\ngh = stack.build username: 'rkh', password: 'abc123'\r\nputs gh['user']['name']\r\n```\r\n\r\nOne such instance (with the standard setup) can be accessed as `GH::DefaultStack`\r\n\r\n### Scoping\r\n\r\nWith the main goal to separate authentication from other logic, the `gh` library supports scopting:\r\n\r\n``` ruby\r\nGH.with GH::LazyLoader.new do\r\n  puts GH['users/rkh']['name']\r\nend\r\n```\r\n\r\nThat way, you could create a stack with, for instance, an [access token](http://developer.github.com/v3/oauth/):\r\n\r\n``` ruby\r\nauthenticated = GH::DefaultStack token: 'e72e16c7e42f292c6912e7710c838347ae178b4a'\r\n\r\nGH.with(authenticated) do\r\n  # ...\r\nend\r\n```\r\n\r\nSince this is rather common, you can pass options directly to `with`:\r\n\r\n``` ruby\r\nGH.with(username: 'rkh', password: 'abc123') do\r\n  # ...\r\nend\r\n```\r\n\r\nScoping is thread-safe.\r\n\r\n### Is this production ready?\r\n\r\nI hope so, we use it in production for [Travis CI](http://travis-ci.org/). The work on this library has been funded by the [Travis Love Campaign](https://love.travis-ci.org/).\r\n\r\n### History\r\n\r\n* 2012-04-10: 0.2.2 - improved link following\r\n* 2012-04-10: 0.2.1 - bug fix release\r\n* 2012-04-10: 0.2.0 - added link following plus bug fixes (mainly encoding issues)\r\n* 2012-04-06: 0.1.2 - bug fix release (issues with cache reloading)\r\n* 2012-04-06: 0.1.1 - bug fix release (DSL fixes)\r\n* 2012-04-04: 0.1.0 - many bug fixes plus lazy loading\r\n* 2012-03-21: 0.0.1 - first public release\r\n* 2012-03-05: project started","tagline":"Layered GitHub API client","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}